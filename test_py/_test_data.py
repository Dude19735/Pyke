import numpy as np
from scipy.spatial.transform import Rotation as R

class TestData:
    def __init__(self):
        pass

###############################################################################################################
#                                       ██████  ███████ ███████  █████                                        #
#                                       █     █ █     █    █    █     █                                       #
#                                       █     █ █     █    █    █                                             #
#                                       █     █ █     █    █     █████                                        #
#                                       █     █ █     █    █          █                                       #
#                                       █     █ █     █    █    █     █                                       #
#                                       ██████  ███████    █     █████                                        #
###############################################################################################################
    @staticmethod
    def Point_P(angle):
        points = np.array([
            [ 0, 0, 0],
            [ 1, 1, 1],
            [-1, 1, 1],
            [-1,-1, 1],
            [ 1,-1, 1],
            [ 1, 1,-1],
            [-1, 1,-1],
            [-1,-1,-1],
            [ 1,-1,-1]              
        ], np.float32)

        r = R.from_euler('z', angle, degrees=True)
        return (points @ r.as_matrix()).astype(np.float32)

    @staticmethod
    def Point_C():
        colors = np.array([
            [1.0,   1.0,   1.0],
            [1.0,   0,   0    ],
            [0,   1.0,   0    ],
            [0,     0, 1.0    ],
            [1.0, 1.0,   0    ],
            [0,   1.0, 1.0    ],
            [1.0,   0, 1.0    ],
            [1.0, 0.5,   0    ],
            [0.5,   0, 0.5    ]              
        ], np.float32)

        return colors
    
    @staticmethod
    def Point_P_C_Indices():
        return np.array([0, 1, 2, 3, 4, 5, 6, 7, 8], np.uint32)


###############################################################################################################
#                                     █       ███ █     █ ███████  █████                                      #
#                                     █        █  ██    █ █       █     █                                     #
#                                     █        █  █ █   █ █       █                                           #
#                                     █        █  █  █  █ █████    █████                                      #
#                                     █        █  █   █ █ █             █                                     #
#                                     █        █  █    ██ █       █     █                                     #
#                                     ███████ ███ █     █ ███████  █████                                      #
###############################################################################################################
    @staticmethod
    def Line_P(angle):
        points = np.array([
            [ 1, 1, 1],
            [-1, 1, 1],
            [-1,-1, 1],
            [ 1,-1, 1],
            [ 1, 1,-1],
            [-1, 1,-1],
            [-1,-1,-1],
            [ 1,-1,-1],            
        ], np.float32)

        r = R.from_euler('z', angle, degrees=True)
        return (points @ r.as_matrix()).astype(np.float32)
    
    @staticmethod
    def Line_C():
        colors = np.array([
            [1.0,   0,   0],
            [0,   1.0,   0],
            [0,     0, 1.0],
            [1.0, 1.0,   0],
            [0,   1.0, 1.0],
            [1.0,   0, 1.0],
            [1.0, 0.5,   0],
            [0.5,   0, 0.5]              
        ], np.float32)

        return colors
    
    @staticmethod
    def Line_P_C_Indices():
        return np.array([
            0,1,  1,2,  2,3,  3,0,
            4,5,  5,6,  6,7,  7,4,
            0,4,  1,5,  2,6,  3,7
        ], np.uint32)

###############################################################################################################
#                █████  ███████ ███████ ██████  ██████           █████  █     █  █████  ███████               #
#               █     █ █     █ █     █ █     █ █     █         █     █  █   █  █     █    █                  #
#               █       █     █ █     █ █     █ █     █         █         █ █   █          █                  #
#               █       █     █ █     █ ██████  █     █          █████     █     █████     █                  #
#               █       █     █ █     █ █   █   █     █               █    █          █    █                  #
#               █     █ █     █ █     █ █    █  █     █         █     █    █    █     █    █                  #
#                █████  ███████ ███████ █     █ ██████           █████     █     █████     █                  #
###############################################################################################################
    @staticmethod
    def Coords_P(
        from_x:float, to_x:float, tip_len_x:float, 
        from_y:float, to_y:float, tip_len_y:float, 
        from_z:float, to_z:float, tip_len_z:float):
        return np.array([
            [        from_x,              0,              0],
            [to_x-tip_len_x,              0,              0],
            [          to_x,              0,              0],
            [             0,         from_y,              0],
            [             0, to_y-tip_len_y,              0],
            [             0,           to_y,              0],
            [             0,              0,         from_z],
            [             0,              0, to_z-tip_len_z],
            [             0,              0,           to_z]
        ], np.float32)
    
    @staticmethod
    def Coords_C(tip_r:float, tip_g:float, tip_b:float):
        return np.array([
            [  1.0,     0,     0], 
            [  1.0,     0,     0], 
            [tip_r, tip_g, tip_b],
            [    0,   1.0,     0], 
            [    0,   1.0,     0], 
            [tip_r, tip_g, tip_b],
            [    0,     0,   1.0], 
            [    0,     0,   1.0], 
            [tip_r, tip_g, tip_b]
        ], np.float32)
    
    @staticmethod
    def Coords_P_C_Indices():
        return np.array([
            0,1,  1,2,
            3,4,  4,5,
            6,7,  7,8
        ], np.uint32)


###############################################################################################################
#    █████  █     █ ██████  ███████         █     █ ███████         █     █ ███████ ██████  █     █  █████    #
#   █     █ █     █ █     █ █               █  █  █ █     █         ██    █ █     █ █     █ ██   ██ █     █   #
#   █       █     █ █     █ █               █  █  █ █     █         █ █   █ █     █ █     █ █ █ █ █ █         #
#   █       █     █ ██████  █████           █  █  █ █     █         █  █  █ █     █ ██████  █  █  █  █████    #
#   █       █     █ █     █ █               █  █  █ █     █         █   █ █ █     █ █   █   █     █       █   #
#   █     █ █     █ █     █ █               █  █  █ █     █         █    ██ █     █ █    █  █     █ █     █   #
#    █████   █████  ██████  ███████          ██ ██  ███████         █     █ ███████ █     █ █     █  █████    #
###############################################################################################################
    @staticmethod
    def Cube1_P(angle:float):
        points = np.array([
            [ 1, 1, 1],
            [-1, 1, 1],
            [-1,-1, 1],
            [ 1,-1, 1],
            [ 1, 1,-1],
            [-1, 1,-1],
            [-1,-1,-1],
            [ 1,-1,-1]              
        ], np.float32)

        r = R.from_euler('z', angle, degrees=True)
        return (points @ r.as_matrix()).astype(np.float32)
    
    @staticmethod
    def Cube1_C():
        return np.array([
            [1.0,   0,   0],
            [0,   1.0,   0],
            [0,     0, 1.0],
            [1.0, 1.0,   0],
            [0,   1.0, 1.0],
            [1.0,   0, 1.0],
            [1.0, 0.5,   0],
            [0.5,   0, 0.5]              
        ], np.float32)

    @staticmethod
    def Cube1_P_C_Indices():
        return np.array([
            0,1,2,  2,3,0, # top
            0,5,1,  0,4,5, # back
            3,7,0,  7,4,0, # right 
            1,5,2,  5,6,2, # left 
            7,3,2,  2,6,7, # front 
            7,6,5,  5,4,7  # bottom
        ], np.uint32)


###############################################################################################################
#        █████  █     █ ██████  ███████         █     █         █     █ ███████ ██████  █     █  █████        #
#       █     █ █     █ █     █ █               █  █  █         ██    █ █     █ █     █ ██   ██ █     █       #
#       █       █     █ █     █ █               █  █  █         █ █   █ █     █ █     █ █ █ █ █ █             #
#       █       █     █ ██████  █████           █  █  █         █  █  █ █     █ ██████  █  █  █  █████        #
#       █       █     █ █     █ █               █  █  █         █   █ █ █     █ █   █   █     █       █       #
#       █     █ █     █ █     █ █               █  █  █         █    ██ █     █ █    █  █     █ █     █       #
#        █████   █████  ██████  ███████          ██ ██          █     █ ███████ █     █ █     █  █████        #
###############################################################################################################
    @staticmethod
    def Cube2_P(angle:float):
        points = np.array([
            [ 1, 1, 1],
            [ 1, 1, 1],
            [ 1, 1, 1],
            [-1, 1, 1],
            [-1, 1, 1],
            [-1, 1, 1],
            [-1,-1, 1],
            [-1,-1, 1],
            [-1,-1, 1],
            [ 1,-1, 1],
            [ 1,-1, 1],
            [ 1,-1, 1],
            [ 1, 1,-1],
            [ 1, 1,-1],
            [ 1, 1,-1],
            [-1, 1,-1],
            [-1, 1,-1],
            [-1, 1,-1],
            [-1,-1,-1],
            [-1,-1,-1],
            [-1,-1,-1],
            [ 1,-1,-1],
            [ 1,-1,-1],
            [ 1,-1,-1]
        ], np.float32)

        r = R.from_euler('z', angle, degrees=True)
        return (points @ r.as_matrix()).astype(np.float32)
    
    @staticmethod
    def Cube2_N(angle:float):
        points = np.array([
            [ 0, 0, 1],
            [ 0, 1, 0],
            [ 1, 0, 0],
            [ 0, 0, 1],
            [ 0, 1, 0],
            [-1, 0, 0],
            [ 0, 0, 1],
            [-1, 0, 0],
            [ 0,-1, 0],
            [ 0, 0, 1],
            [ 0,-1, 0],
            [ 1, 0, 0],
            [ 0, 0,-1],
            [ 0, 1, 0],
            [ 1, 0, 0],
            [ 0, 0,-1],
            [ 0, 1, 0],
            [-1, 0, 0],
            [ 0, 0,-1],
            [-1, 0, 0],
            [ 0,-1, 0],
            [ 0, 0,-1],
            [ 0,-1, 0],
            [ 1, 0, 0]
        ], np.float32)

        r = R.from_euler('z', angle, degrees=True)
        return (points @ r.as_matrix()).astype(np.float32)

    @staticmethod
    def Cube2_C():
        return np.array([
            [1.0,   0,   0],
            [1.0,   0,   0],
            [1.0,   0,   0],
            [0,   1.0,   0],
            [0,   1.0,   0],
            [0,   1.0,   0],
            [0,     0, 1.0],
            [0,     0, 1.0],
            [0,     0, 1.0],
            [1.0, 1.0,   0],
            [1.0, 1.0,   0],
            [1.0, 1.0,   0],
            [0,   1.0, 1.0],
            [0,   1.0, 1.0],
            [0,   1.0, 1.0],
            [1.0,   0, 1.0],
            [1.0,   0, 1.0],
            [1.0,   0, 1.0],
            [1.0, 0.5,   0],
            [1.0, 0.5,   0],
            [1.0, 0.5,   0],
            [0.5,   0, 0.5],
            [0.5,   0, 0.5],
            [0.5,   0, 0.5]
        ], np.float32)

    @staticmethod
    def Cube2_P_C_N_Indices():
        return np.array([
             0, 3, 6,   6, 9, 0, # top
             1,16, 4,   1,13,16, # back
            10,22, 2,  22,14, 2, # right 
             5,17, 7,  17,19, 7, # left 
            23,11, 8,   8,20,23, # front 
            21,18,15,  15,12,21  # bottom
        ], np.uint32)


###############################################################################################################
#         █     █ ███████ ██████  █     █    █    █               █       ███ █     █ ███████  █████          #
#         ██    █ █     █ █     █ ██   ██   █ █   █               █        █  ██    █ █       █     █         #
#         █ █   █ █     █ █     █ █ █ █ █  █   █  █               █        █  █ █   █ █       █               #
#         █  █  █ █     █ ██████  █  █  █ █     █ █               █        █  █  █  █ █████    █████          #
#         █   █ █ █     █ █   █   █     █ ███████ █               █        █  █   █ █ █             █         #
#         █    ██ █     █ █    █  █     █ █     █ █               █        █  █    ██ █       █     █         #
#         █     █ ███████ █     █ █     █ █     █ ███████         ███████ ███ █     █ ███████  █████          #
###############################################################################################################
    @staticmethod
    def Cube2_NormalLines_P(len:float, angle:float):
        p = TestData.Cube2_P(angle)
        n = TestData.Cube2_N(angle)
        res = np.empty((p.shape[0] + n.shape[0], p.shape[1]), dtype=p.dtype)
        res[0::2] = p
        res[1::2] = p + len*n

        return res.astype(np.float32)
    
    @staticmethod
    def Cube2_NormalLines_Indices():
        return np.arange(48).astype(np.uint32)
    
    @staticmethod
    def Cube2_NormalLines_C():
        return np.tile(np.array([0.0, 1.0, 0.0], np.float32), 48).reshape((48,3)).astype(np.float32)
